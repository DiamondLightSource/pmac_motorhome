CLOSE

//####################################################
// Autogenerated Homing PLC for PowerBrick, DO NOT MODIFY
// Group 2:
// None
//####################################################


// Homing State P Variable
#define PLC10_HomingState       P1000
#define PLC10_StateIdle         0
#define PLC10_StateConfiguring  1
#define PLC10_StateMoveNeg      2
#define PLC10_StateMovePos      3
#define PLC10_StateHoming       4
#define PLC10_StatePostHomeMove 5
#define PLC10_StateAligning     6
#define PLC10_StateDone         7
#define PLC10_StateFastSearch   8
#define PLC10_StateFastRetrace  9
#define PLC10_StatePreHomeMove  10
PLC10_HomingState = PLC10_StateIdle

// Homing Status P Variable
#define PLC10_HomingStatus      P1001
#define PLC10_StatusDone        0
#define PLC10_StatusHoming      1
#define PLC10_StatusAborted     2
#define PLC10_StatusTimeout     3
#define PLC10_StatusFFErr       4
#define PLC10_StatusLimit       5
#define PLC10_StatusIncomplete  6
#define PLC10_StatusInvalid     7
#define PLC10_StatusPaused      8
#define PLC10_StatusDebugHoming 9
PLC10_HomingStatus = PLC10_StatusDone

// Homing Group P Variable
#define PLC10_HomingGroup       P1002
PLC10_HomingGroup = 0

// Homing Group Backup P Variable
#define PLC10_HomingBackupGroup P1003
PLC10_HomingBackupGroup = 0

open plc 10 

if (PLC10_HomingStatus != PLC10_StatusHoming && PLC10_HomingStatus != PLC10_StatusDebugHoming){
    PLC10_HomingStatus = PLC10_StatusHoming
}

//---- Configuring State ----
PLC10_HomingState=PLC10_StateConfiguring
//Save the Homing group to px03
PLC10_HomingBackupGroup=PLC10_HomingGroup
//Save high soft limits to P variables px04..x19
P1004=Motor[1].MaxPos
//Save the low soft limits to P variables px20..x35
P1020=Motor[1].MinPos
//Save the home capture flags to P variables px36..x51
P1036=Gate3[0].Chan[0].CaptCtrl
//Store 'not flag' to use in moving off a flag in P variables px52..x67
P1052=P1036^12
//Save the limit flags to P variables px68..x83
P1068=Motor[1].pLimits
//Save the current position to P variables px84..x99
P1084=Motor[1].Pos - Motor[1].HomePos
//Clear the soft limits
Motor[1].MaxPos=0
Motor[1].MinPos=0

if ((PLC10_HomingBackupGroup == 1 || PLC10_HomingBackupGroup == 2) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming)){
    PLC10_HomingGroup=2

    //Clear home flags
    // Can't clear home on PBRICK
    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- PreHomeMove State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StatePreHomeMove
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastSearch State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastSearch
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^0
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Store the difference between current pos and start pos ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        P1084=(P1084 - (Motor[1].Pos - Motor[1].HomePos)) + 0 - Motor[1].HomeOffset
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastRetrace State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastRetrace
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1052 Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^0
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- Homing State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateHoming
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1036
        home1
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Zero encoder channels ----
    if ((PLC10_HomingStatus == PLC10_StatusHoming) || (PLC10_HomingStatus == PLC10_StatusDebugHoming)){
        homez9
    }
    //---- Check if all motors have homed ----
    if ((PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) &&(Motor[1].HomeComplete == 0 )){
        PLC10_HomingStatus=PLC10_StatusIncomplete
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- PostHomeMove State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StatePostHomeMove
        // Execute the move commands
        Motor[1].ProgJogPos=P1004
        jog1=*
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 ) && (Motor[1].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[1].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

}

//---- Done ----
if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
    //If we've got this far without failing, set status and state done
    PLC10_HomingStatus=PLC10_StatusDone
    PLC10_HomingState=PLC10_StateDone
    //Restore the homing group from px03
    PLC10_HomingGroup=PLC10_HomingBackupGroup
}

//---- Tidy Up ----
//Stop all motors if they don't have a following error
if (Motor[1].FeFatal == 0){
    jog/1
}
//Restore the high soft limits from P variables px04..x19
Motor[1].MaxPos=P1004
//Restore the low soft limits from P variables px20..x35
Motor[1].MinPos=P1020
//Restore the home capture flags from P variables px36..x51
Gate3[0].Chan[0].CaptCtrl=P1036
//Restore the limit flags to P variables px68..x83
Motor[1].pLimits=P1068

disable plc 10
close
